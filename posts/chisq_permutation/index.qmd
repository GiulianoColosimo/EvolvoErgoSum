---
title: "A test of HWE using permutations (to be completed)"
description: "An example with microsatellite data and R"
author:
  - name: Giuliano Colosimo
    url: 
date: "2023-11-21"
# date-modified: "2023-09-12"
categories: ["R", "Chi square", "Permutation", "Statistics"]
# image: 
format: 
  html:
    toc: true
engine: knitr
bibliography: /Users/giulianocolosimo/Library/CloudStorage/ProtonDrive-giuliano.colosimo@protonmail.com/manuscripts/literature/bibtex/comprehensive_database.bib
csl: /Users/giulianocolosimo/Library/CloudStorage/ProtonDrive-giuliano.colosimo@protonmail.com/manuscripts/literature/bibtex/evolutionary-ecology-research.csl
citation_package: biblatex
citecolor: "red"
---

# Introduction

Working with microsatellite genotypes data for many years I always wanted to fully understand how to build a test to verify whether the population(s) under analysis is(are) in Hardy-Weinberg (HW) equilibrium [@Hardy1908] (or, to be more precise, if the population's genotypes reflects HW proportions). Checking for HW proportions is generally the first step in any kind of population genetic analysis [@Waples2019].

One of the most basic approach to perform such a test is to use the $\chi^{2}$ method [@Allendorf2022]. This approach is particularly useful when the number of loci and alleles is too big to perform a Fisher's Exact Test [@Fisher1935]. The straight up formula of the $\chi^{2}$ test is relatively simple: $\chi^{2} = \sum\frac{(OBSERVED-EXPECTED)^2}{EXPECTED}$, where OBSERVED and EXPECTED refer to the number of observed and expected genotypes for each locus and allele. The computed $\chi^{2}$ value is then compared to a set of values obtained under the assumption of no violation of the $H_0$.


```{r chisq}
#| code-fold: true
#| code-summary: "Show the R code used to produce the graph"
#| label: fig-chisq
#| fig-cap: $\chi^{2}$ distribution graph showing the test statistic on the y axis and its associated p-value on the x axis. The test statistic is calculated with different Degrees of Freedom (DoF). The red dashed line marks the widely used  threshold of p-value = 0.05 under which we can reject $H_0$. As DoF increases, the test statistic value needed to reject $H_0$ gets higher.  

chiTestVal <- 
  seq(0, 10, by = 0.001)

plot(1-pchisq(chiTestVal, df = 1), chiTestVal, type = "l",
     main = expression(chi^2*"distribution"),
     ylab = "Test Statistic Value",
     xlab = "p-value", lwd = 2)
lines(1-pchisq(chiTestVal, df = 2), chiTestVal, type = "l",
      lwd = 2, col = "blue")
lines(1-pchisq(chiTestVal, df = 3), chiTestVal, type = "l",
      lwd = 2, col = "green")
lines(1-pchisq(chiTestVal, df = 4), chiTestVal, type = "l",
      lwd = 2, col = "brown")
lines(1-pchisq(chiTestVal, df = 5), chiTestVal, type = "l",
      lwd = 2, col = "deeppink")
abline(v=0.05, col = "red", lty = 2, lwd = 2)
legend("topright", 
       legend = c("DoF = 1", "DoF = 2", "DoF = 3", "DoF = 4", "DoF = 5"), 
       col = c("black", "blue", "green", "brown", "deeppink"), lty = 1)
```

While the $\chi^{2}$ test is applied in many different situations, there are some cases, for example when there are many genotypes with low expected numbers due the presence of many different alleles, where a different approach may serve us better in testing $H_0$: permutation tests [@Allendorf2022].

The overall idea behind this approach is to recreate X number of randomized datasets starting from the observed data. For each generated dataset a $\chi^{2}$ value is then calculated and compared with the value obtained from the original dataset. The proportion of randomized dataset that produce a $\chi^{2}$ value as large as or lager than the observed data gives us an unbiased estimate of the probability of rejecting $H_0$ [@Allendorf2022].

In this post I will show how I build a permutation test procedure to evaluate the probability of rejecting $H_0$ when working with microsatellite genotypes. I will be using a microsatellite dataset available from Dryad (click [here](https://drive.proton.me/urls/W9206FWP1C#LlZJdXqsWypn) to download). The dataset is borrowed from @Chan2020 and consists of 27 microsatellites typed in 237 individuals. The original dataset is available in **<font color="green"> genpop </font>** format. This is a widely used format in R applications and in population genetics analyses. 

The procedure illustrated here works directly with matrices. Therefore in this first part I will cover the step-by-step procedure to transition from **<font color="green"> genpop </font>** to **<font color="green"> matrix </font>** format. 

# Data wrangling

To load the data file, encoded in **<font color="green"> genpop </font>** format, we will be using one of the most populat package for genetic analyses in R: **adegenet** [@Jombart2008a]. I will assume you have the package already installed locally on your computer. So, the first thing to do is to load the data file using the following code:

```{r loadDataShow, echo=TRUE, eval=FALSE, message=FALSE}
library(adegenet)                                    # package to load
sceloporus_data <- read.genepop("path/to/file.gen",  # specify the path to the genepop file
                                ncode = 3,           # how many digits are used for alleles
                                quiet = T)           # print loading progress on screen
```

```{r loadDataNoShow, echo=FALSE, eval=TRUE, message=FALSE}
library(adegenet)                                    
sceloporus_data <- 
  read.genepop("~/Documents/websites/EvolvoErgoSum/data/doi_10.5061_dryad.sxksn0316__v2/microsatellite_genotypes.gen",  
               ncode = 3,           
               quiet = T)
```

The *read.genepop()* function from **adegenet** automatically converts the data in to a  **<font color="green"> genind </font>**  object, the data format used by **adegenet**. We can take a look at what it is like just by typing the name of data.

```{r seeData, echo=TRUE}
sceloporus_data
```

This data format is quite useful as it gives a first glance of what is that we are dealing with. Unfortunately this is not the format needed to perform this custom test. In fact this permutation procedure takes as input file a matrix of genotypes. Rather than giving you an example right now I think is best if we proceed and transform the dataset so that you can see how the input file should look like. The first step is to transform the data object in a data frame.

```{r genind2df, echo=TRUE}
sceloporus_data_df <- genind2df(sceloporus_data)
sceloporus_data_df[1:10, 1:9]
```

By inspecting the first 10 individuals and 9 loci we notice that the function has nicely organized our individuals in rows, kept the population information in the first column, and used the other columns for the genotypes. This format is very close to what we need, but not quite yet. First, we change the coding scheme of missing genotypes:

```{r missingGeno, echo=TRUE}
sceloporus_data_df[apply(sceloporus_data_df, 2, is.na)] <- "000000"
sceloporus_data_df[1:10, 1:9]
```

Just a few more lines of code to transform everything from a data frame to a matrix and retain all the information that may be useful down the road.

```{r data_matrix, echo=TRUE}
#| code-fold: true
#| code-summary: "Show the R code"
sceloporus_data_mt <- apply(sceloporus_data_df[,-1], 2, function(x){
  paste(substr(x, 1, 3), substr(x, 4, 6), sep = "/")
})
sceloporus_data_mt <- cbind(as.character(sceloporus_data_df[,1]), sceloporus_data_mt)
rownames(sceloporus_data_mt) <- rownames(sceloporus_data_df)
sceloporus_data_mt[1:10, 1:7]
```

# Next step coming soon...

# References